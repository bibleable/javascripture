<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<script src="data/bible.js"></script>
		<script src="data/morphhb.js"></script>
        <script src="data/tischendorf.js"></script>
        <script src="lib/MorphCodes.js"></script>
        <script src="lib/MorphParse.js"></script>
        <script src="lib/morphgnt-parse.js"></script>
		<script>
            var javascripture = { data: {} };
			var data = Object.assign( {}, morphhb, tischendorf );
		</script>
        <script src="data/literalConsistent.js"></script>
        <script src="data/lemmas.js"></script>
        <script src="data/literalConsistentExtra.js"></script>
        <script>
		var words = {};
        function getWordFromWord( word ) {
			if ( word && word.length > 0 ) {
			    return word[0];
			}

			return null;
		}
		function getLemmaFromWord( word ) {
			if ( word && word.length > 0 ) {
			    return word[1];
			}

			return null;
		}

        function getMorphFromWord( word ) {
			if ( word && word.length > 0 ) {
			    return word[2];
			}

			return null;
        }

        function ConvertToCSV( words ) {
            var str = '';

            Object.keys( words ).forEach( word => {
                Object.keys( words[ word ] ).forEach( lemma => {
                    Object.keys( words[ word ][ lemma ] ).forEach( morph => {
                        let morphCode;
                        if ( lemma.indexOf( 'G' ) === 0 ) {
                            morphCode = parseGreekMorph( morph );
                        } else {
                            const morphParseObject = new MorphParse();
                            morphCode = morphParseObject.Parse( morph );
                        }

                        str += word + ','
                        str += lemma + ','
                        str += morph + ','
                        str += morphCode + ','
                        str += words[ word ][ lemma ][ morph ]
                        str += '<br />';
                    } );
                } );
            } );

            return str;
        }

		function generateCSV() {
            var morphString = '';
            bible.Data.allBooks.forEach( book => data[ book ].forEach( ( chapter, chapterNumber ) => chapter.forEach( ( verse, verseNumber ) => verse.forEach( word => {
                const wordString = getWordFromWord( word );
                const lemma = getLemmaFromWord( word );
                const morph = getMorphFromWord( word )
                if ( lemma ) {
                    wordArray = wordString.split('/');
                    lemmaArray = lemma.split('/');
                    morphArray = morph.split('/');

                    wordArray.forEach( ( wordInArray, key ) =>  {
                        var wordForWord = wordInArray.replace(/[,Â·;\.:]+\s*$/, "").toLowerCase();
                        if ( ! words[ wordForWord ] ) {
                            words[ wordForWord ] = {};
                        }

                        var lemmaForWord = lemmaArray[ key ];
                        if ( ! lemmaForWord ) {
                            lemmaForWord = 'no-lemma';
                        }

                        if ( ! words[ wordForWord][ lemmaForWord ] ) {
                            words[ wordForWord][ lemmaForWord ] = {};
                        }

                        var morphForWord = morphArray[ key ];
                        if ( ! morphForWord ) {
                            morphForWord = 'no-morph';
                        }

                        if ( morph.indexOf( 'H' ) === 0 && key > 0 ) {
                            morphForWord = 'H' + morphForWord;
                        }

                        if ( morph.indexOf( 'A' ) === 0 && key > 0 ) {
                            morphForWord = 'A' + morphForWord;
                        }

                        var literalTranslation = '';
                        if ( javascripture.data.literalConsistent[ lemmaForWord ] ) {
                            if ( javascripture.data.literalConsistent[ lemmaForWord ][ morphForWord.substr(1) ] ) {
                                literalTranslation = javascripture.data.literalConsistent[ lemmaForWord ][ morphForWord.substr(1) ];
                            } else if ( javascripture.data.literalConsistent[ lemmaForWord ][ 'no-morph' ] ) {
                                literalTranslation = javascripture.data.literalConsistent[ lemmaForWord ][ 'no-morph' ];
                            } else {
                                var morphWeHave = Object.keys( javascripture.data.literalConsistent[ lemmaForWord ] )[0];
                                literalTranslation = javascripture.data.literalConsistent[ lemmaForWord ][ morphWeHave ];
                            }
                        }

                        words[ wordForWord][ lemmaForWord ][ morphForWord ] = literalTranslation;
                    } );

                }
            } ) ) ) );
            document.getElementById('results').innerHTML = ConvertToCSV( words );
        }

        function generateObject() {
            var file = document.getElementById( 'upload' ).files[0];
            if (file) {
                var reader = new FileReader();
                reader.readAsText(file, "UTF-8");
                reader.onload = function (evt) {
                    var listOfWords = evt.target.result.split('\r\n');
                    listOfWords.shift();
                    //console.log( listOfWords );
                    listOfWords.forEach( word => {
                        var wordArray = word.split( ',' );
                        if ( ! words[ wordArray[0] ] ) {
                            words[ wordArray[0] ] = {};
                        }

                        if ( ! words[ wordArray[0] ][ wordArray[1] ] ) {
                            words[ wordArray[0] ][ wordArray[1] ] = {};
                        }

                        words[ wordArray[0] ][ wordArray[1] ][ wordArray[2] ] = [ wordArray[3] ]
                    } );
                    document.getElementById("results").innerHTML = JSON.stringify( words );
                }
                reader.onerror = function (evt) {
                    document.getElementById("results").innerHTML = "error reading file";
                }
}

        }
		</script>
	</head>
	<body>
		<H1>CSV creator</h1>
		<p>This tool creates a CSV of every lemma and morphology combination in the original text. Use it to generate a CSV that can be shared with others so the process of creating a literal translation can be shared.</p>
        <button onClick="generateCSV()">Generate CSV</button>
        <input id="upload" type="file" /><button onClick="generateObject()">Generate Object</button>
		<br />
		<br />
		<div id="results"></div>
	</body>
</html>
